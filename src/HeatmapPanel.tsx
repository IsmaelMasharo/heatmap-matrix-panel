// @ts-nocheck
import React from 'react';
import * as d3 from 'd3';
import { PanelProps } from '@grafana/data';
import { HeatmapOptions } from 'types';

interface Props extends PanelProps<HeatmapOptions> {}

export const HeatmapPanel: React.FC<Props> = ({ options, data, width, height }) => {
  // -----------------------    CHART CONSTANTS    -----------------------
  const CHART_REQUIRED_FIELDS = { pivot: 'Period' };

  // -----------------------  CHART CONFIGURATION  -----------------------
  const config = {
    background: '#f8f8fa',
    removeEmptyCols: true,
  };

  // ----------------------- BASE DATA ACQUISITION -----------------------
  const frame = data.series[0];
  const dataLen = frame.length;

  // -----------------------       ACCESSORS      -----------------------
  const pivotAccesor = frame.fields.find(field => field.name === CHART_REQUIRED_FIELDS.pivot);
  const baseCategoryFields = frame.fields.filter(field => field.name !== CHART_REQUIRED_FIELDS.pivot);
  const categoryFields = !config.removeEmptyCols
    ? baseCategoryFields
    : baseCategoryFields.filter(field => d3.sum(field.values.toArray()) > 0);

  // const NonNumericColumns = categoryFields.find(field => field.type !== 'number')

  // -----------------------      VALIDATIONS     -----------------------
  if (!pivotAccesor) {
    throw new Error(`Required fields not present: ${Object.keys(CHART_REQUIRED_FIELDS).join(', ')}`);
  }

  // if (NonNumericColumns) {
  //   throw new Error(`Non numeric categories present.`);
  // }

  // -----------------------  CHART FIELD VALUES  -----------------------
  const pivots = pivotAccesor.values.toArray();
  const categories = categoryFields.map(field => field.name);

  const pivotIndices = d3.range(dataLen);

  // -----------------------    CHART DIMENSIONS  -----------------------
  const dimensions = {
    width: width,
    height: height,
    marginTop: 40,
    marginRight: 20,
    marginBottom: 20,
    marginLeft: 60,
  };

  dimensions.boundedWidth = dimensions.width - dimensions.marginLeft - dimensions.marginRight;
  dimensions.boundedHeight = dimensions.height - dimensions.marginTop - dimensions.marginBottom;

  // -----------------------    CHART ELEMENTS    -----------------------
  // COLOR BY VALUES
  const colorInterpolator = d3[`interpolate${config.color}`];

  // domain starts at -1 to avoid using the lighter tone generated by interpolator
  const colorByIndex = d3
    .scaleSequential()
    .domain([-1, dataLen])
    .interpolator(colorInterpolator);

  // COLOR BY CATEGORIES (VERTICAL)
  // COLOR BY PIVOT (HORIZONTAL)
  const color = d3
    .scaleLinear()
    .domain([-1.5, 0, 1.5])
    .range(['red', 'rgb(250, 248, 193)', 'green'])
    .interpolate(d3.interpolateRgb);

  // SCALES
  const x = d3
    .scaleBand()
    .domain(categories)
    .range([0, dimensions.boundedWidth])
    .padding(0.2);

  const y = d3
    .scaleBand()
    .domain(pivots)
    .range([dimensions.boundedHeight, 0])
    .padding(0.2);

  // AXIS
  const xAxis = g =>
    g
      .call(
        d3
          .axisTop(x)
          .tickSize(0)
          .tickSizeOuter(0)
      )
      .call(g => g.select('.domain').remove())
      .selectAll('text')
      .attr('dy', '.5em')
      .style('text-anchor', 'midle');

  const yAxis = g =>
    g
      .call(
        d3
          .axisLeft(y)
          .tickSize(0)
          .tickPadding(4)
      )
      .call(g => g.select('.domain').remove())
      .selectAll('text')
      .attr('x', 5);

  // VALUE FORMATING
  const formatValue = (category, pivotIndex) =>
    parseFloat(d3.format('.2f')(categoryFields.find(field => field.name === category).values.get(pivotIndex)));

  const chart = svg => {
    // SVG STYLING
    svg.style('background-color', config.background);

    // BOUNDS
    const bounds = svg.append('g').attr('transform', `translate(${dimensions.marginLeft}, ${dimensions.marginTop})`);

    // MATRIX
    bounds
      .selectAll('g')
      .data(pivotIndices)
      .join('g')
      .each((pivotIndex, i, nodes) => {
        const itemPositionY = y(pivotAccesor.values.get(pivotIndex));

        const item = d3
          .select(nodes[i])
          .selectAll('g')
          .data(categories)
          .join('g');

        item
          .append('rect')
          .attr('x', category => x(category))
          .attr('y', itemPositionY)
          .attr('width', x.bandwidth())
          .attr('height', y.bandwidth())
          .attr('fill', category => {
            const currentValue = formatValue(category, pivotIndex);
            const previousValue = formatValue(category, pivotIndex - 1) || 0;
            let change = (currentValue - previousValue) / previousValue;
            // clamping change to avoid using the stronger tone generated by interpolator
            change = change > 1 ? 1 : change < -1 ? -1 : change;

            return currentValue === 0 ? color(0) : previousValue === 0 ? color(0.5) : color(change);
          })
          .append('title')
          .text(category => formatValue(category, pivotIndex));

        item
          .append('text')
          .attr('font-size', 10)
          .attr('pointer-events', 'none')
          .attr('text-anchor', 'middle')
          // .attr('x', category => x(category) + x.bandwidth() / 2)
          // .attr('y', itemPositionY + y.bandwidth() / 2)
          .call(text =>
            text
              .append('tspan')
              .attr('x', category => x(category) + x.bandwidth() / 2)
              .attr('y', itemPositionY + y.bandwidth() / 2)
              .each((category, i, nodes) => {
                const itemValue = formatValue(category, pivotIndex);
                const previousValue = formatValue(category, pivotIndex - 1) || 0;
                const currentNode = d3.select(nodes[i]);

                // move up a little => room for percentage change
                currentNode.attr('dy', itemValue && previousValue ? '-0.4em' : '.35em');
                // display totals if total > 0
                currentNode.text(itemValue ? d3.format('.3~s')(itemValue) : '-');
              })
          )
          .call(text =>
            text
              .append('tspan')
              .attr('x', category => x(category) + x.bandwidth() / 2)
              .attr('y', itemPositionY + y.bandwidth() / 2)
              .each((category, i, nodes) => {
                const currentValue = formatValue(category, pivotIndex);
                const previousValue = formatValue(category, pivotIndex - 1) || 0;
                const change = (currentValue - previousValue) / previousValue;
                if (currentValue && previousValue) {
                  // display percentage change bellow totals
                  d3.select(nodes[i])
                    .attr('dy', '1em')
                    .text(d3.format('.1%')(change));
                }
              })
          );
      });

    // AXIS
    bounds.append('g').call(xAxis);

    bounds.append('g').call(yAxis);
  };

  return (
    <svg
      viewBox={`0 0 ${dimensions.width} ${dimensions.height}`}
      ref={node => {
        d3.select(node)
          .selectAll('*')
          .remove();
        d3.select(node).call(chart);
      }}
    />
  );
};
